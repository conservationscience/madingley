# This file is all of the code needed to match species to the Madingley outputs
# You only need to change your working directory to the directory that you 
# downloaded the GitHub repository to.


############################################################################
### Setup file names
############################################################################
library( readxl )
library("dplyr")
library( functionaltraits )
library( stringr )

#####
# Configure the locations that variables will be saved
#####
# By convention, anything generated by this code is stored in a folder called "outputs"
# The output data changes depending on what species list you choose
# Therefore, the code creates a different folder for each species list, so that
# the output data is clearly separated for each list that is given

filename_species_list <- "mapoflife_serengeti_headerremoved.csv"

file_species_list <- file.path( "species_lists", filename_species_list)

# create the output folder for this species list, if it doesn't exist
if( !dir.exists( file.path("outputs", filename_species_list) ) ) {
  dir.create( file.path("outputs", filename_species_list), recursive = TRUE )
}

# the trait data from functionaltraits package
file_trait_data <- file.path( "outputs", filename_species_list, "trait_data.csv" )
file_trait_data_statistics <-  file.path( "outputs", filename_species_list, "trait_data_statistics.csv" )

# the trait data after processing, used to match with Madingley outputs
file_processed_trait_data <-  file.path( "outputs", filename_species_list, "processed_trait_data.csv" )

# note that we have added this folder to the project's "ignored files" list
# this is so that we don't upload copies of the databases, which would be breach of copyright
file_functionaltraits_data <- file.path("outputs", "functionaltraits_data" )




# Choose the species list you want to load
species_list <- read.table( 
  file_species_list, 
  sep=",", header=TRUE, stringsAsFactors=FALSE, quote="" )
species_list <- species_list$Scientific.Name

# select a location to store the databases files on your computer
databases <- functionaltraits::Databases$new( file_functionaltraits_data ) 

databases <- functionaltraits::Databases$new('outputs/functionaltraits_data/')

### SS - This came up with Error: 'Databases' is not an exported object from 'namespace:functionaltraits'

# check databases are ready
databases$ready()

# you have to download the databases the first time
databases$initialise()

# check that they downloaded properly
databases$ready()

############################################################################
### Get the trait data, and save it
############################################################################

# make sure there is only one of each species in the list
species_list <- unique( species_list )

# use previous trait data if it is available
if( file.exists( file_trait_data ) && file_exists( file_trait_data_statistics ) ) {
  trait_data <- read.table( file_trait_data, header=TRUE, sep=",")  
  trait_data_statistics <- read.table( file_trait_data_statistics, header=TRUE )
}
else {
  tmp <- find_species_traits( databases, species_list )
  trait_data <- tmp$results
  trait_data_statistics <- tmp$statistics
  write.csv( trait_data, file = file_trait_data )
  write.csv( trait_data_statistics, file = file_trait_data_statistics )
  
}



############################################################################
### Process the trait data into relevant variables used to match with Madingley
############################################################################

processed_trait_data <- trait_data[ ,c(
  "taxa", "found", "synonyms", "accepted_name", "common_name",
  "kingdom", "phylum", "class", "order", "family", "genus" 
)]

processed_trait_data$energy_source <- compute_column(
  input = trait_data,
  calculator = function( species ) {
    if( !is.na( species$kingdom ) ) {
      
      # if the phylum is not Chordata, then it's not endothermic
      if( species$kingdom == "Animalia" ) {
        return( "heterotroph" )
        
      }
      else if( species$kingdom == "Plantae" ) {
        return( "autotroph" )
      }
      else return( NA )
    }
    else return( NA )
  }
)

processed_trait_data$thermoregulation = compute_column(
  input = trait_data,
  calculator = function( species ) {
    # the rule for this code is
    # if it's in Aves or if it's in Mammalia, then it's an endotherm
    # if it's not, then it's an ectotherm
    # there are some edge cases eg. in some fish which they shiver or use muscles to
    # produce some warmth, but primarily I think the models and most people
    # would still consider these ectotherms rather than strictly regulated endotherms
    # like mammals and birds
    
    # check if phylum information is available, else return NA
    if( !is.na( species$phylum ) ) {
      
      # if the phylum is not Chordata, then it's not endothermic
      if( species$phylum == "Chordata" ) {
        
        if( !is.na( species$class) ) {
          # have to check the classes
          if( species$class == "Mammalia" ) {
            return( "endotherm" )
          }
          else if( species$class == "Aves" ) {
            return( "endotherm" )
          }
          else return( "ectotherm" )
        }
        else return( NA )
        
      }
      else {
        return( "ectotherm" )
      }
    }
    else return( NA )
  }
)


# these functions take in a row of the dataframe, and
# return either "herbivore", "omnivore", "carnivore" or NA depending on
# what database c they take information from
get_jones_trophiclevel <- function( species ) {
  if( !is.na( species[[ "jones_X6.2_TrophicLevel"]] ) ) {
    # need to convert the numbering system in pantheria (1=herbivore,2=omnivore,3=carnivore)
    return( case_when(
      species[["jones_X6.2_TrophicLevel"]] == 1 ~ "herbivore",
      species[["jones_X6.2_TrophicLevel"]] == 2 ~ "omnivore",
      species[["jones_X6.2_TrophicLevel"]] == 3 ~ "carnivore",
      species[["jones_X6.2_TrophicLevel"]] == NA ~ "NA"
    ) )
  }
  else return(NA)
}

get_kissling_trophiclevel <- function( species ) {
  if( !is.na( species[["kissling_TrophicLevel"]] ) ) {
    # need to make the text lowercase
    return( tolower( species[["kissling_TrophicLevel"]] ) )
  }
  else return(NA)
}

get_wilman_bird_trophiclevel <- function( species ) {
  if( !is.na( species[["wilman_bird_Diet.5Cat"]] ) ) {
    # need to convert the system in eltontraits
    # PlantSeed or FruiNect = herbivore; Omnivore = omnivore; Invertebrate or VertFishScav = carnivore;
    return( case_when(
      species[["wilman_bird_Diet.5Cat"]] == "PlantSeed" ~ "herbivore",
      species[["wilman_bird_Diet.5Cat"]] == "FruiNect" ~ "herbivore",
      species[["wilman_bird_Diet.5Cat"]] == "Omnivore" ~ "omnivore",
      species[["wilman_bird_Diet.5Cat"]] == "Invertebrate" ~ "carnivore",
      species[["wilman_bird_Diet.5Cat"]] == "VertFishScav" ~ "carnivore",
      species[["wilman_bird_Diet.5Cat"]] == NA ~ "NA"
    ) )
  }
  else return( NA )
}

get_olivira_trophiclevel <- function( species ) {
  # if any one of the oliveira columns isn't a NA, then we can use it.
  
  # the logic is; if it only eats (leaves, flowers, seeds or fruits) then it's a herbivore
  # if it only eats (athro or verts) then it's a carnivore
  # if it eats from either of the above, it's an omnivore
  if( 
    !is.na( species[[ "oliveira_Leaves" ]] ) 
    || !is.na( species[[ "oliveira_Flowers"]] )
    || !is.na( species[[ "oliveira_Seeds"]] )
    || !is.na( species[[ "oliveira_Fruits"]] )
    || !is.na( species[[ "oliveira_Arthro"]] )
    || !is.na( species[[ "oliveira_Vert"]] )
  ) {
    # first lets group the variables into two categories
    herbivore <- case_when(
      species[[ "oliveira_Leaves"]] == 1 ~ TRUE,
      species[[ "oliveira_Flowers"]] == 1 ~ TRUE,
      species[[ "oliveira_Seeds"]] == 1 ~ TRUE,
      species[[ "oliveira_Fruits"]] == 1 ~ TRUE,
      # default value is FALSE
      1 == 1 ~ FALSE
    )
    carnivore <- case_when(
      species[[ "oliveira_Arthro"]] == 1 ~ TRUE,
      species[[ "oliveira_Vert"]] == 1 ~ TRUE,
      # default value is FALSE
      1 == 1 ~ FALSE
    )
    # if it's a herbivore and a carnivore, then it's an omnivore
    if( herbivore == TRUE && carnivore == TRUE ) {
      return( "omnivore" )
    }
    # and logically the rest follows
    else if( herbivore == FALSE && carnivore == TRUE ) {
      return( "carnivore" )
    }
    else if( herbivore == TRUE && carnivore == FALSE ) {
      return( "herbivore" )
    }
  }
  else return( NA )
}


######################################################
### This code was for looking at the different diet information in each database
# processed_trait_data$n_jones <-  rep( NA, nrow( processed_trait_data ) )
# processed_trait_data$n_kissling<-rep( NA, nrow( processed_trait_data ) )
# processed_trait_data$n_wilman_bird<-rep( NA, nrow( processed_trait_data ) )
# processed_trait_data$n_olivira<-rep( NA, nrow( processed_trait_data ) )
# processed_trait_data$n_ambigous <- rep( NA, nrow( output ) )
######################################################

processed_trait_data$nutrition_source<-rep( NA, nrow( processed_trait_data ) )

#### loop through the dataframe and calculate the columns
# this code is very inefficient and slow but it gets the job done
for( i in 1:nrow( trait_data ) ) {
  
  # get the information from each database column, so it's easy to work with
  jones <- get_jones_trophiclevel( as.list( trait_data[i, ] ) )
  kissling <- get_jones_trophiclevel( as.list( trait_data[i, ] ) )
  wilman_bird <- get_wilman_bird_trophiclevel( as.list( trait_data[i, ] ) )
  olivira <- get_olivira_trophiclevel( as.list( trait_data[i, ] ) )
  
  # add it to the output
  #processed_trait_data[[ i, "n_jones"]] <- jones
  #processed_trait_data[[ i, "n_kissling"]] <- kissling
  #processed_trait_data[[ i, "n_wilman_bird"]] <- wilman_bird
  #processed_trait_data[[ i, "n_olivira"]] <- olivira
  
  # calculate nutrition_source column and also whether that value is caluclated from
  # multiple databases (n_ambigious)
  all_values <- c( jones, kissling, wilman_bird, olivira )
  all_values <- na.omit( unique( all_values ) )
  
  # If there's only one value then we take that value
  if( length(all_values) == 1 ) {
    processed_trait_data[[ i, "nutrition_source"]] <- all_values
    #processed_trait_data[[ i, "n_ambigous"]] <- FALSE
  }
  
  # if there's more than one value, then we take the most inclusive category ()
  else if( length( all_values > 1 ) ) {
    ## if omnivore is present by any of the databases, then we assume that it's an omnivore
    # regardless of whether another database thinks it's a carnivore or herbivore
    if( any("omnivore" %in% all_values) ) {
      processed_trait_data[[ i, "nutrition_source" ]] <- "omnivore"
      #processed_trait_data[[ i, "n_ambigous"]] <- TRUE
    }
    else if( any("carnivore" %in% all_values) && any("herbivore" %in% all_values) ) {
      processed_trait_data[[ i, "nutrition_source" ]] <- "omnivore"
      #processed_trait_data[[ i, "n_ambigous"]] <- TRUE
    }
    else if( any("carnivore" %in% all_values) ) {
      processed_trait_data[[ i, "nutrition_source" ]] <- "carnivore"
      #processed_trait_data[[ i, "n_ambigous"]] <- TRUE
    }
    else if( any("herbivore" %in% all_values) ) {
      processed_trait_data[[ i, "nutrition_source" ]] <- "herbivore"
      #processed_trait_data[[ i, "n_ambigous"]] <- TRUE
    }
  }
  
}

bodymass_columns <- c(
  "jones_X5.1_AdultBodyMass_g",
  "tacutu_Adult.weight..g.",
  "slavenko_Maximum_mass_g",
  "fishbase_Weight",
  "oliveira_Body_mass_g",
  "myhrvold_adult_body_mass_g",
  "earnst_mass.g.",
  "lislevand_M_mass",
  "lislevand_F_mass",
  "wilman_bird_BodyMass.Value",
  "wilman_mam_BodyMass.Value",
  "pacifici_AdultBodyMass_g"
)

processed_trait_data$bodymass = compute_column(
  input = trait_data,
  calculator = function( species ) {
    species <- species[bodymass_columns]
    # get all the bodymass values in the columns for this row; remove duplicates; and remove NA values
    bodymass_values <- na.omit( 
      unique(
        round( as.numeric( species ), digits = 0 )
      )
    )
    if( length( bodymass_values > 0 ) ) {
      ##### calculate bodymass as a median value ########
      ##### changes this if you want to calculate it in some other way #####
      ### note that bodymass_values is rounded & has all of the unique values removed though ####
      return( median( bodymass_values ) )
    }
    else return( NA )
  }
)

# TODO - check if the range is actually calculated provl

processed_trait_data$bodymass_range = compute_column(
  input = trait_data,
  calculator = function( species ) {
    species <- species[bodymass_columns]
    # get all the bodymass values in the columns for this row; remove duplicates; and remove NA values
    bodymass_values <- na.omit( 
      unique(
        round( as.numeric( species ), digits = 0 )
      )
    )
    
    if( length( bodymass_values )  == 0  ) return( NA )
    else if( length( bodymass_values ) == 1 ) return( NA )
    else if( length( bodymass_values ) > 1 ) {
      print( bodymass_values)
      return( diff( range( bodymass_values ) ) )
    }
    else return( NA )
  }
)




# if you want to see the bodymass columns with the processed data,
# you can use the following line of code:
# processed_trait_data <- cbind( processed_trait_data, trait_data[ , bodymass_columns ] )

############################################################################
### Develop functional group keys to match processed trait data with Madingley output
############################################################################

# Load the Madingley Output files needed (there should be five: Subset_massbins, 
# NewCohorts, CohortFunctionalGroupDefinitions, MassBinDefinitions and 
# SimulationControlParameters)

## Will need to consolidate input working directory ....

setwd("N:/Quantitative-Ecology/Indicators-Project/Indicator_inputs")

resultsDir <- 'Serengeti/Baseline/Biomass/'
all_functionalgroups <- read.csv(paste(resultsDir, "CohortFunctionalGroupDefinitions.csv", sep = "")) # should not change between runs
lowermassbins <- read.csv(paste(resultsDir,'MassBinDefinitions.csv', sep = "")) # could change if user changes mass bins
simulationparameters <- read.csv(paste(resultsDir,'SimulationControlParameters.csv', sep = "")) #Can change between runs

# Calculate upper massbins and join with lower bins output by model

Mass.bin.upper.bound <- c(max(lowermassbins) + 100000, 
                              lowermassbins$Mass.bin.lower.bound[1:77])

massbins <- cbind(lowermassbins, Mass.bin.upper.bound) %>%
            mutate(bodymass_index = c((nrow(lowermassbins) - 1):0))


# Retrieve the burnin period from your simulation outputs

## NOTE: baseline sets burn-in as zero so need to an add if-statement so it
## adds 1000 if calculating for baseline scenario

# burn_in <- 1000

burn_in <- as.numeric(as.character(simulationparameters[3,2])) * 12 

# Set your realm (marine or terrestrial)

realm <- "Terrestrial"
#realm <- "Marine"

# Develop unique key for each model functional group 

## Add the functional group index and subset functional groups by realm

subset_functionalgroups <-  all_functionalgroups %>%
                            mutate(FG_id = c(0:18)) %>% # Add zero based index
                            filter(DEFINITION_Realm == realm) %>%
                            select(DEFINITION_Heterotroph.Autotroph,
                            DEFINITION_Nutrition.source,
                            DEFINITION_Endo.Ectotherm,
                            DEFINITION_Reproductive.strategy,
                            FG_id)


## Process model functional groups so we collapse groups differentiated by
## reproductive strategy, because the abundance/biomass model output doesn't 
## actually differentiate between these groups. (NOTE - this code has not been 
## tested on marine groups)

## Create groups to loop through the df 

trophic <- unique(subset_functionalgroups$DEFINITION_Heterotroph.Autotroph)
nutrition <- unique(subset_functionalgroups$DEFINITION_Nutrition.source)
metabol <- unique(subset_functionalgroups$DEFINITION_Endo.Ectotherm)

## Break down each level of functional group until you get to reproductive strategy.
## Where trophic level, nutrition and metabolic pathways are the same but reproductive
## strategy differs, collapse the functional group id

merged_functionalgroups_temp <- data.frame()

for(troph in trophic){
  temp1 <- subset_functionalgroups %>% 
    filter(DEFINITION_Heterotroph.Autotroph == troph)
  for(diet in nutrition){
    temp2 <- temp1 %>% filter(DEFINITION_Nutrition.source == diet)
    for(therm in metabol){
      temp3 <- temp2 %>% filter(DEFINITION_Endo.Ectotherm == therm)
      temp3$functionalgroup_index <- temp3$FG_id
      if(nrow(temp3) > 1){
        functionalgroup_index <- paste(temp3$FG_id, collapse = '.')
        temp3$functionalgroup_index <- functionalgroup_index
      }
      
      merged_functionalgroups_temp <- rbind(merged_functionalgroups_temp, temp3)
      
    }
  }
}

rm(temp1, temp2, temp3)

## Subset the merged functional group dataframe to include only one row for 
## merged groups

merged_functionalgroups <- merged_functionalgroups_temp %>% 
                           select(-FG_id, 
                           -DEFINITION_Reproductive.strategy) %>%
                           distinct() %>%
                           mutate(fg.name = tolower(paste(
                             DEFINITION_Nutrition.source,
                             DEFINITION_Endo.Ectotherm, sep = " ")))

# Repeat the massbins by number of merged functional groups

replicated_massbins <- replicate(nrow(merged_functionalgroups), massbins, 
                                   simplify = FALSE)
replicated_massbins <- do.call(rbind, replicated_massbins)

# Likewise, create a mirrored repetition of each functional group by number
# of bodymass bins. Final replicated_massbins and replicated_functional groups
# should have the same number of rows
  
replicated_functionalgroups <- merged_functionalgroups %>% 
                               slice(rep(1:n(), 
                               each = nrow(massbins)))
                                   
                                   
## Merge replicated bodymass and functional group dataframes to create a 
## species definition dataframe, list and index

species_definitions <-  data.frame(replicated_functionalgroups, 
                                   replicated_massbins) %>%
                        mutate(species_index = paste(functionalgroup_index, 
                               bodymass_index, sep = ".")) 

species_definitions_list <- split(species_definitions, 
                                  species_definitions$fg.name)


############################################################################
### Develop functional group keys to match processed trait data with Madingley output
############################################################################


